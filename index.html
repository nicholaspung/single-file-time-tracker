<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Time Tracker</title>
    <link rel="manifest" href="/manifest.json">
    <style>
        .toast {
            background-color: #333;
            color: white;
            padding: 16px;
            margin: 16px;
            opacity: 0.9;
            transition: bottom 0.5s, opacity 0.5s;
        }
    </style>
</head>
<body>
    <div id="timeTracker">
        <h4>Track time</h4>
        <input type="text" id="timeTrackerDescriptionInput" placeholder="Enter task description" />
        <select id="timeTrackerCategorySelect">
            <option value="" selected>Select category</option>
        </select>
        <select id="timeTrackerTagsSelect" multiple>
        </select>
        <div>
            <input type="datetime-local" id="timeTrackerStartTimeInput" />
            <button id="setToLastStopTimeTodayButton" onclick="setToLastStopTimeToday()">Set to last stop time today</button>
        </div>
        <input type="datetime-local" id="timeTrackerStopTimeInput" />
        <div id="timeRecordsModal" style="display:none; position:fixed; left:0; top:0; width:100%; height:100%; background-color:rgba(0,0,0,0.5);">
            <div style="background-color:white; margin:10% auto; padding:20px; width:80%;">
                <div>
                    <h4>Edit time record</h4>
                    <input type="text" id="editTimeTrackerDescriptionInput" placeholder="Enter task description" />
                    <select id="editTimeTrackerCategorySelect">
                        <option value="" selected>Select category</option>
                    </select>
                    <select id="editTimeTrackerTagsSelect" multiple>
                    </select>
                    <div>
                        <input type="datetime-local" id="editTimeTrackerStartTimeInput" />
                        <button id="setToLastStopTimeTodayButton" onclick="setToLastStopTimeToday()">Set to last stop time today</button>
                    </div>
                    <input type="datetime-local" id="editTimeTrackerStopTimeInput" />
                </div>
                <br />
                <button id="timeRecordsCloseButton" onclick="toggleModalAndDeleteClassName('timeRecordsModal')">Close</button>
            </div>
        </div>
        <br />
        <button id="startButton" onclick="startTimer()">Start</button>
        <button id="startPomodoroTimerButton" onclick="startTimer(defaultPomodoroRecord, startPomodoroTimer)">Start Pomodoro</button>
        <button id="startBreakTimerButton" onclick="startTimer(defaultPomodoroBreakRecord, startBreakTimer)">Start Break</button>
        <button id="updateTimeButton" style="display: none;" onclick="updateTimeRecord()">Update</button>
        <button id="stopButton" style="display: none;" onclick="stopTimer()">Stop</button>
        <button id="addTimeButton" onclick="addTimeRecord()">Save</button>
        <div id="timerDisplay">00:00:00</div>
        <div id="pomodoroTimerDisplay"></div>
    </div>
    <div>
        <h4>Pomodoro settings</h4>
        <div>
            <label for="pomodoroTime">Pomodoro time: </label>
            <input type="number" id="pomodoroTime" value="25" min="1"> min
        </div>
        <div>
            <label for="pomodoroAlert">Show pomodoro alert</label>
            <input type="checkbox" id="pomodoroAlert" />
        </div>
        <button id="savePomodoroButton" onclick="setPomodoroConfigLocalStorage('pomodoro')">Save pomodoro config</button>
        <br>
        <div>
            <label for="breakTime">Break time: </label>
            <input type="number" id="breakTime" value="5" min="1"> min
        </div>
        <div>
            <label for="breakAlert">Show break alert</label>
            <input type="checkbox" id="breakAlert" />
        </div>
        <button id="savePomodoroButton" onclick="setPomodoroConfigLocalStorage('break')">Save break config</button>
    </div>
    <h4>Tracked time records</h4>
    <div id="timeTrackerDisplayArea"></div>
    <h4>Categories for time tracking</h4>
    <div id="trackerCategory">
        <input type="text" id="trackerCategoryCategoryInput" placeholder="Enter category" />
        <button onclick="createTrackerCategory()">Save</button>
    </div>
    <div id="trackerCategoryDisplayArea"></div>
    <div id="trackerCategoryModal" style="display:none; position:fixed; left:0; top:0; width:100%; height:100%; background-color:rgba(0,0,0,0.5);">
        <div style="background-color:white; margin:10% auto; padding:20px; width:80%;">
            <div>
                <h4>Edit category</h4>
                <input type="text" id="editTrackerCategoryCategoryInput" placeholder="Enter category" />
            </div>
            <br />
            <button id="trackerCategoryCloseButton" onclick="toggleModalAndDeleteClassName('trackerCategoryModal')">Close</button>
        </div>
    </div>
    <h4>Tags for time tracking</h4>
    <div id="trackerTag">
        <input type="text" id="trackerTagTagInput" placeholder="Enter tag" />
        <button  onclick="createTrackerTag()">Save</button>
    </div>
    <div id="trackerTagDisplayArea"></div>
    <div id="trackerTagModal" style="display:none; position:fixed; left:0; top:0; width:100%; height:100%; background-color:rgba(0,0,0,0.5);">
        <div style="background-color:white; margin:10% auto; padding:20px; width:80%;">
            <div>
                <h4>Edit tag</h4>
                <input type="text" id="editTrackerTagTagInput" placeholder="Enter tag" />
            </div>
            <br />
            <button id="trackerTagCloseButton" onclick="toggleModalAndDeleteClassName('trackerTagModal')">Close</button>
        </div>
    </div>
    <div id="toastContainer" style="position: fixed; bottom: 0; right: 0;"></div>
    <!-- Hotkey Display Modal -->
    <div id="hotkeyModal" style="display:none; position:fixed; left:0; top:0; width:100%; height:100%; background-color:rgba(0,0,0,0.5);">
        <div style="background-color:white; margin:10% auto; padding:20px; width:80%;">
            <h2>Hotkeys</h2>
            <p><strong>Shift + 1:</strong> Focus track time input</p>
            <p><strong>Shift + 2:</strong> Focus pomodoro settings</p>
            <p><strong>Shift + 3:</strong> Focus category input</p>
            <p><strong>Shift + 4:</strong> Focus tag input</p>
            <p><strong>/:</strong> Open hotkey tips</p>
            <p><strong>Esc:</strong> Close hotkey tips</p>
            <button onclick="toggleModal('hotkeyModal')">Close</button>
        </div>
    </div>
    <script>
        let db;
        // DB is NoSQL, but I'd like it to function like a SQL database, with "JOINS"
        const timeRecordsDB = 'timeRecords'
        const categoryRecordsDB = 'categoryRecords'
        const tagsRecordsDB = 'tagsRecords'

        let defaultStartTime, latestRecord;

        let timeTrackingRecords = []
        let pomodoroConfig = {}

        let currentStartTime, intervalId, timeoutId, currentTimeRecord;

        function openDatabase(callbacks) {
            const request = indexedDB.open("TimeTrackerDB", 1);

            request.onupgradeneeded = function(e) {
                db = e.target.result;

                // create object stores
                if (!db.objectStoreNames.contains(timeRecordsDB)) {
                    db.createObjectStore(timeRecordsDB, { autoIncrement: true });
                }
                if (!db.objectStoreNames.contains(categoryRecordsDB)) {
                    const categoryRecordStore = db.createObjectStore(categoryRecordsDB, { autoIncrement: true });
                }
                if (!db.objectStoreNames.contains(tagsRecordsDB)) {
                    const tagRecordStore = db.createObjectStore(tagsRecordsDB, { autoIncrement: true });
                }

                // create indexes
                const upgradeTransaction = event.target.transaction
                if (db.objectStoreNames.contains(categoryRecordsDB)) {
                    const categoryRecordStore = upgradeTransaction.objectStore(categoryRecordsDB)
                    if (!categoryRecordStore.indexNames.contains('category')) {
                        categoryRecordStore.createIndex('category', 'category', { unique: true })
                    }
                }
                if (db.objectStoreNames.contains(tagsRecordsDB)) {
                    const tagRecordsObjectStore = upgradeTransaction.objectStore(tagsRecordsDB)
                    if (!tagRecordsObjectStore.indexNames.contains('tag')) {
                        tagRecordsObjectStore.createIndex('tag', 'tag', { unique: true })
                    // } else {
                        // example of how to reset an index
                        // need to delete it first in 1 upgrade, then in the next upgrade create it back
                        // tagRecordsObjectStore.deleteIndex('tag')
                        // tagRecordsObjectStore.createIndex('tag', 'tag', { unique: true })
                    }
                }
            };

            request.onsuccess = async function(e) {
                db = e.target.result;
                for (let i = 0; i < callbacks.length; i += 1) {
                    await callbacks[i]()
                }
            };

            request.onerror = function(e) {
                console.error("Error opening database: ", e);
            };
        }

        function formatTime(date) {
            if (!date) {
                return ''
            }
            let hours = date.getHours();
            const minutes = date.getMinutes().toString().padStart(2, '0');
            const ampm = hours >= 12 ? 'PM' : 'AM';
            hours = hours % 12;
            hours = hours ? hours : 12; // the hour '0' should be '12'
            return hours.toString().padStart(2, '0') + ':' + minutes + ' ' + ampm;
        }

        function formatElapsedTime(elapsedTime) {
            if (!elapsedTime) {
                return ''
            }
            const hours = Math.floor(elapsedTime / (1000 * 60 * 60));
            const minutes = Math.floor((elapsedTime % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((elapsedTime % (1000 * 60)) / 1000);

            return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function sortTimeRecordsByLatestToOldest() {
            const recordWNoStopTime = timeTrackingRecords.filter(function(record) {
                return !record.stopTime
            })[0]

            let records = [];
            if (recordWNoStopTime) {
                records.push(recordWNoStopTime)
            }

            timeTrackingRecords.sort((a,b) => {
                if (a.stopTime < b.stopTime) { return 1 }
                else if (a.stopTime > b.stopTime) { return -1 }
                else return 0
            })

            let recordsWStopTime = timeTrackingRecords.filter(function(record) {
                return record.stopTime
            })
            
            return [...records, ...recordsWStopTime ] 
        }

        function removeDuplicatesAndReplaceUpdatedRecord() {
            const keys = {}
            return timeTrackingRecords.reduce(function(acc, curr, index) {
                if (!keys[curr.key]) {
                    keys[curr.key] = { index, value: curr }
                    acc.push(curr)
                } else {
                    if (JSON.stringify(curr) !== JSON.stringify(keys[curr.key].value)) {
                        console.log(keys[curr.key]);
                        acc[keys[curr.key].index] = curr
                    }
                }
                return acc
            }, [])
        }
        
        function getEditTimeTrackingRecordsInputs() {
            let taskDescription = document.getElementById('editTimeTrackerDescriptionInput').value;
            let category = document.getElementById('editTimeTrackerCategorySelect').value;
            let tagsSelect = getSelectedValues('editTimeTrackerTagsSelect');
            let startTime = new Date(document.getElementById('editTimeTrackerStartTimeInput').value)
            let stopTime = new Date(document.getElementById('editTimeTrackerStopTimeInput').value)

            return {
                description: taskDescription,
                category,
                tags: tagsSelect,
                startTime,
                stopTime
            }
        }
        function openEditTimeRecordsModalWData(recordJsonString, modalId) {
            const record = JSON.parse(recordJsonString.replaceAll('|', '"'))
            setValuesBasedOnTimeRecord(record, {
                descriptionInputId: 'editTimeTrackerDescriptionInput',
                categorySelectId: 'editTimeTrackerCategorySelect',
                tagsSelectId: 'editTimeTrackerTagsSelect',
                startTimeInput: 'editTimeTrackerStartTimeInput',
                stopTimeInput: 'editTimeTrackerStopTimeInput'
            })
            
            const updateButton = document.createElement("button");
            updateButton.textContent = "Update";
            updateButton.className = "deleteMeOnUpdateOrClose"
            updateButton.onclick = function() {
                const updatedRecord = getEditTimeTrackingRecordsInputs()
                editRecordField(timeRecordsDB, record.key, updatedRecord)
                toggleModalAndDeleteClassName(modalId)
            }
            const referenceElement = document.getElementById('timeRecordsCloseButton');
            referenceElement.parentNode.insertBefore(updateButton, referenceElement);

            toggleModal(modalId)
        }
        function openEditTrackerCategoryModalWData(recordJsonString, modalId, key) {
            const record = JSON.parse(recordJsonString.replaceAll('|', '"'))
            document.querySelector('#editTrackerCategoryCategoryInput').value = record.category
            
            const updateButton = document.createElement("button");
            updateButton.textContent = "Update";
            updateButton.className = "deleteMeOnUpdateOrClose"
            updateButton.onclick = function() {
                const updatedCategory = document.querySelector('#editTrackerCategoryCategoryInput').value
                editRecordField(categoryRecordsDB, key, { category: updatedCategory})
                // function to be made
                // map through timetrackingrecords, check if any category === record
                // if true, update timetracking record with new category, else do nothing
                // call fetch time tracking record
                toggleModalAndDeleteClassName(modalId)
            }
            const referenceElement = document.getElementById('trackerCategoryCloseButton');
            referenceElement.parentNode.insertBefore(updateButton, referenceElement);

            toggleModal(modalId)
        }
        function openEditTrackerTagModalWData(recordJsonString, modalId, key) {
            const record = JSON.parse(recordJsonString.replaceAll('|', '"'))
            document.querySelector('#editTrackerTagTagInput').value = record.tag
            
            const updateButton = document.createElement("button");
            updateButton.textContent = "Update";
            updateButton.className = "deleteMeOnUpdateOrClose"
            updateButton.onclick = function() {
                const updatedTag = document.querySelector('#editTrackerTagTagInput').value
                editRecordField(tagsRecordsDB, key, { tag: updatedTag})
                toggleModalAndDeleteClassName(modalId)
            }
            const referenceElement = document.getElementById('trackerTagCloseButton');
            referenceElement.parentNode.insertBefore(updateButton, referenceElement);

            toggleModal(modalId)
        }
        function generateActionCells(row, db, key, record, modalId) {
            // Cell for Edit and Delete buttons
            const cell = row.insertCell();
            cell.innerHTML = `
                <button onclick="openEdit${capitalizeFirstLetter(modalId)}WData('${JSON.stringify(record).replaceAll('"', "|")}', '${modalId}', ${key})">Edit</button>
                <button onclick="deleteRecord('${db}', ${key})">Delete</button>
            `;
        }
        function displayTimeTrackerRecords() {
            const timeTrackerDisplayArea = document.getElementById('timeTrackerDisplayArea');
            timeTrackerDisplayArea.innerHTML = ''; // Clear previous entries

            // Create a table and header row
            const table = document.createElement('table');
            table.innerHTML = `
                <tr>
                    <th>Description</th>
                    <th>Category</th>
                    <th>Tags</th>
                    <th>Time Range</th>
                    <th>Total Time</th>
                    <th>Actions</th>
                </tr>`;
            timeTrackerDisplayArea.appendChild(table);

            timeTrackingRecords.forEach(function(record) {
                const row = table.insertRow();

                const startTime = new Date(record.startTime);
                let stopTime = null;
                let elapsedTime = null
                if (record.stopTime) {
                    stopTime = new Date(record.stopTime);
                    elapsedTime = new Date(stopTime - startTime);
                }

                const timeRange = `${formatTime(startTime)} - ${formatTime(stopTime)}`;
                const totalElapsedTime = formatElapsedTime(elapsedTime);

                createCell(timeRecordsDB, row, record.description);
                createCell(timeRecordsDB, row, record.category);
                const tags = record.tags && record.tags.length > 0 ? record.tags.join(', ') : '';
                createCell(timeRecordsDB, row, tags);
                createCombinedCell(timeRecordsDB, row, 
                    [{ textContent: formatTime(startTime), field: 'startTime'}, 
                        { textContent: formatTime(stopTime), field: 'stopTime'}], 
                    ' - ')
                createCell(timeRecordsDB, row, totalElapsedTime);

                generateActionCells(row, timeRecordsDB, record.key, record, 'timeRecordsModal')
            })
        }
        function fetchTimeTrackerRecords() {
            const transaction = db.transaction([timeRecordsDB], "readonly");
            const store = transaction.objectStore(timeRecordsDB);
            const request = store.openCursor();

            request.onsuccess = function(event) {
                const cursor = event.target.result;
                if (cursor) {
                    const record = cursor.value;
                    timeTrackingRecords.push({ ...record, key: cursor.key })
                    cursor.continue();
                } else {
                    timeTrackingRecords = sortTimeRecordsByLatestToOldest()
                    timeTrackingRecords = removeDuplicatesAndReplaceUpdatedRecord()
                    checkIfLatestRecordIsNotFinished();
                    displaySetToLastStopTimeTodayButton();
                    displayTimeTrackerRecords();
                }
            };

            request.onerror = function(event) {
                console.error("Error in retrieving records: ", event);
            };
        }

        function displayTrackerCategory() {
            const transaction = db.transaction([categoryRecordsDB], "readonly");
            const store = transaction.objectStore(categoryRecordsDB);
            const request = store.openCursor();

            const trackerCategoryDisplayArea = document.getElementById('trackerCategoryDisplayArea');
            trackerCategoryDisplayArea.innerHTML = ''; // Clear previous entries

            // Create a table and header row
            const table = document.createElement('table');
            table.innerHTML = `
                <tr>
                    <th>Category</th>
                    <th>Actions</th>
                </tr>`;
            trackerCategoryDisplayArea.appendChild(table);
            resetSelectToDefault('timeTrackerCategorySelect');

            request.onsuccess = function(event) {
                const cursor = event.target.result;
                if (cursor) {
                    const record = cursor.value;
                    const row = table.insertRow();

                    createCell(categoryRecordsDB, row, record.category);

                    generateActionCells(row, categoryRecordsDB, cursor.key, cursor.value, 'trackerCategoryModal')

                    // also adds the category values to select
                    addOptionToSelect('timeTrackerCategorySelect', cursor.value.category)
                    addOptionToSelect('editTimeTrackerCategorySelect', cursor.value.category)

                    cursor.continue();
                }
            };

            request.onerror = function(event) {
                console.error("Error in retrieving records: ", event);
            };
        }

        function displayTrackerTag() {
            const transaction = db.transaction([tagsRecordsDB], "readonly");
            const store = transaction.objectStore(tagsRecordsDB);
            const request = store.openCursor();

            const trackerTagDisplayArea = document.getElementById('trackerTagDisplayArea');
            trackerTagDisplayArea.innerHTML = ''; // Clear previous entries

            // Create a table and header row
            const table = document.createElement('table');
            table.innerHTML = `
                <tr>
                    <th>Tag</th>
                    <th>Actions</th>
                </tr>`;
            trackerTagDisplayArea.appendChild(table);
            resetSelectToDefault('timeTrackerTagsSelect', true);

            request.onsuccess = function(event) {
                const cursor = event.target.result;
                if (cursor) {
                    const record = cursor.value;
                    const row = table.insertRow();

                    createCell(tagsRecordsDB, row, record.tag);

                    generateActionCells(row, tagsRecordsDB, cursor.key, cursor.value, 'trackerTagModal')
                    
                    // also adds the tag values to select
                    addOptionToSelect('timeTrackerTagsSelect', cursor.value.tag)
                    addOptionToSelect('editTimeTrackerTagsSelect', cursor.value.tag)


                    cursor.continue();
                }
            };

            request.onerror = function(event) {
                console.error("Error in retrieving records: ", event);
            };
        }

        function refreshDisplayAccordingToDb(db) {
            if (db === timeRecordsDB) {
                fetchTimeTrackerRecords();
            } else if (db === categoryRecordsDB) {
                displayTrackerCategory();
            } else if (db === tagsRecordsDB) {
                displayTrackerTag();
            }
        }

        function getDateTimeLocalValueFromDate(date) {
            if (date) {
                return date.getFullYear() + '-' +
                            (date.getMonth() + 1).toString().padStart(2, '0') + '-' +
                            date.getDate().toString().padStart(2, '0') + 'T' +
                            date.getHours().toString().padStart(2, '0') + ':' +
                            date.getMinutes().toString().padStart(2, '0');
            } else {
                const now = new Date()
                return now.getFullYear() + '-' +
                            (now.getMonth() + 1).toString().padStart(2, '0') + '-' +
                            now.getDate().toString().padStart(2, '0') + 'T' +
                            '00:00'
            }
        }

        function setDefaultDateForStartTimeAndStopTimeInput() {
            defaultStartTime = getDateTimeLocalValueFromDate();
            document.getElementById('timeTrackerStartTimeInput').value = defaultStartTime;
            document.getElementById('timeTrackerStopTimeInput').value = defaultStartTime;
        }

        async function editRecordField(recordDb, key, record, field, value) {
            const transaction = db.transaction([recordDb], "readwrite");
            const store = transaction.objectStore(recordDb);

            // TO BE UPDATED
            const updatedRecord = {...record}
            if (field && value) {
                updatedRecord[field] = value            
            }
            console.log(updatedRecord, key);
            const request = await store.put(updatedRecord, key);

            request.onsuccess = function(e) {
                const record = e.target.result;
                console.log("Record updated successfully", record);
                refreshDisplayAccordingToDb(recordDb); // Refresh the displayed records
            };

            request.onerror = function(e) {
                console.error("Error updating record: ", e.target.error);
            };
        }

        function removeRecordFromArrayByKey(db, key) {
            if (db === timeRecordsDB) {
                const index = timeTrackingRecords.findIndex(function(el) {
                    return el.key === key
                })
                timeTrackingRecords.splice(index, 1)
                displaySetToLastStopTimeTodayButton();
            }
        }
        function deleteRecord(recordDb, key) {
            const transaction = db.transaction([recordDb], "readwrite");
            const store = transaction.objectStore(recordDb);
            store.delete(key);

            transaction.oncomplete = function(e) {
                console.log("Record deleted successfully");
                // Refresh the displayed records
                showToast(`Record deleted from ${recordDb}`)
                removeRecordFromArrayByKey(recordDb, key)
                refreshDisplayAccordingToDb(recordDb);
            };

            transaction.onerror = function(e) {
                console.error("Error deleting record: ", e.target.error);
            };
        }

        function addOptionToSelect(elementId, data) {
            const selectElement = document.getElementById(elementId);
            const option = document.createElement('option');
            option.value = data;
            option.textContent = data;
            selectElement.appendChild(option);
        }

        function resetSelectToDefault(elementId, removeFirst = false) {
            const selectElement = document.getElementById(elementId);
            if (removeFirst) {
                selectElement.innerHTML = ''
            } else {
                // Remove all options except the first one
                while (selectElement.options.length > 1) {
                    selectElement.remove(1);
                }
                // Optionally reset the first option to be selected
                selectElement.selectedIndex = 0;
            }
        }

        function fetchPomodoroConfigLocalStorage() {
            const fetchedPomodoroConfig = localStorage.getItem('pomodoroConfig')
            if (fetchedPomodoroConfig) {
                pomodoroConfig = fetchedPomodoroConfig ? JSON.parse(fetchedPomodoroConfig) : {};
                document.getElementById('pomodoroTime').value = pomodoroConfig.pomodoroTime
                document.getElementById('breakTime').value = pomodoroConfig.breakTime
                document.getElementById('pomodoroAlert').checked = pomodoroConfig.pomodoroAlert
                document.getElementById('breakAlert').checked = pomodoroConfig.breakAlert
            } else {
                localStorage.setItem('pomodoroConfig', JSON.stringify({
                    pomodoroTime: 25,
                    pomodoroAlert: true,
                    breakTime: 5,
                    breakAlert: true
                }))
            }
        }

        function setPomodoroConfigLocalStorage(type) {
            const config = { ...pomodoroConfig }
            if (type === 'pomodoro') {
                const pomodoroValue = document.getElementById('pomodoroTime').value
                config.pomodoroTime = pomodoroValue
                const pomodoroAlertValue = document.getElementById('pomodoroAlert').checked
                config.pomodoroAlert = pomodoroAlertValue
                showToast('Pomodoro config saved')
            } else {
                const breakValue = document.getElementById('breakTime').value
                config.breakTime = breakValue
                const breakAlertValue = document.getElementById('breakAlert').checked
                config.breakAlert = breakAlertValue
                showToast('Break config saved')
            }
            pomodoroConfig = config
            localStorage.setItem('pomodoroConfig', JSON.stringify(config))
        }

        function toLocalDateTimeStringUsingLocale(date) {
            // Format the date to "YYYY-MM-DDTHH:mm"
            const options = { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', hour12: false };
            let formattedDate = date.toLocaleString('sv-SE', options); // 'sv-SE' helps to ensure the use of ISO-like format (YYYY-MM-DDTHH:mm)
            return formattedDate.replace(' ', 'T'); // Ensure the format matches "YYYY-MM-DDTHH:mm"
        }
        function setValuesBasedOnTimeRecord(record, config = {
            descriptionInputId: 'timeTrackerDescriptionInput',
            categorySelectId: 'timeTrackerCategorySelect',
            tagsSelectId: 'timeTrackerTagsSelect',
            startTimeInput: 'timeTrackerStartTimeInput',
            stopTimeInput: ''
        }) {
            document.getElementById(config.descriptionInputId).value = record.description;
            document.getElementById(config.categorySelectId).value = record.category;

            record.tags.forEach(tag => {
                let option = Array.from(document.getElementById(config.tagsSelectId).options).find(option => option.value === tag);
                if (option) option.selected = true;
            });

            const localStartTime = toLocalDateTimeStringUsingLocale(new Date(record.startTime));
            document.getElementById(config.startTimeInput).value = localStartTime;
            if (config.stopTimeInput) {
                const localStopTime = toLocalDateTimeStringUsingLocale(new Date(record.stopTime));
            document.getElementById(config.stopTimeInput).value = localStopTime;
            }
        }
        function checkIfLatestRecordIsNotFinished() {
            const latestRecord = timeTrackingRecords[0]
            if (!latestRecord.stopTime) {
                // remove latestRecord from state
                timeTrackingRecords.splice(0,1)
                currentTimeRecord = latestRecord
                currentStartTime = new Date(latestRecord.startTime)
                if (latestRecord.tags.includes('pomodoro')) {
                    completePomodoroOrBreakTimeIfPastDuration(latestRecord, 'pomodoro')
                } else if (latestRecord.tags.includes('pomodoro-break')) {
                    completePomodoroOrBreakTimeIfPastDuration(latestRecord, 'pomodoro-break')
                } else {
                    startTimer(latestRecord, undefined, false);
                    setValuesBasedOnTimeRecord(latestRecord);
                }
            }
        }
        function displaySetToLastStopTimeTodayButton() {
            const latestRecord = timeTrackingRecords[0]
            if (latestRecord.stopTime) {
                const lastStopTime = new Date(latestRecord.stopTime)
                const today = new Date()
                if (lastStopTime.getMonth() !== today.getMonth() || lastStopTime.getDate() !== today.getDate()) {
                    document.getElementById('setToLastStopTimeTodayButton').style.display = "none"
                }
            }
        }

        async function completePomodoroOrBreakTimeIfPastDuration(record, type) {
            const now = new Date()
            let duration = 60 * 1000;
            const dateStartTime = new Date(record.startTime)
            if (type === 'pomodoro') {
                duration *= pomodoroConfig.pomodoroTime
            } else if (type === 'pomodoro-break') {
                duration *= pomodoroConfig.breakTime
            }
            if (isPastDuration(now, dateStartTime, duration)) {
                stopTimer(new Date(new Date(record.startTime).getTime() + duration))
            } else {
                if (type === 'pomodoro') {
                    startTimer(record, startPomodoroTimer, false)
                } else if (type === 'pomodoro-break') {
                    startTimer(record, startBreakTimer, false)
                }
            }
        }
        function isPastDuration(now, startTime, duration) {
            // Assuming now, startTime, and duration are all Date objects or time in milliseconds
            const endTime = new Date(startTime.getTime() + duration);
            return now > endTime;
        }

        document.addEventListener('DOMContentLoaded', async function() {
            setDefaultDateForStartTimeAndStopTimeInput()
            fetchPomodoroConfigLocalStorage()
            openDatabase([
                displayTrackerCategory, 
                displayTrackerTag, 
                fetchTimeTrackerRecords, 
                fetchPomodoroConfigLocalStorage,
            ]);
        });
    </script>
    <script>
        /* EDIT TABLE CELL FUNCTIONS */
        function createCombinedCell(recordDb, row, contentArr = [{ textContent: '', field: ''}], joinContent) {
            let cell = row.insertCell();

            const combinedHTML = contentArr.map(content => {
                const span = document.createElement('span');
                span.textContent = content.textContent;
                return span;
            })

            for (let i = 0; i < combinedHTML.length; i += 1) {
                cell.appendChild(combinedHTML[i])
                if (i !== combinedHTML.length - 1) {
                    cell.appendChild(document.createTextNode(joinContent))
                }
            }
        }

        function createCell(recordDb, row, textContent) {
            let cell = row.insertCell();
            cell.textContent = textContent;
        }
    </script>
    <script>
        function toggleModal(id) {
            const modal = document.getElementById(id);
            modal.style.display = modal.style.display === 'none' ? 'block' : 'none';
        }
        function toggleModalAndDeleteClassName(id) {
            const modal = document.getElementById(id);
            modal.style.display = modal.style.display === 'none' ? 'block' : 'none';
            document.querySelector('.deleteMeOnUpdateOrClose').remove()
        }
    </script>
    <script>
        function showToast(message) {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.classList.add('toast');
            toast.textContent = message;

            container.appendChild(toast);

            setTimeout(() => {
                toast.style.opacity = '0';
                setTimeout(() => container.removeChild(toast), 500); // Ensure transition can play before removal
            }, 2000);
        }

        document.addEventListener('keydown', function(event) {
            const hotkeyActions = {
                '/': function() {
                    toggleModal('hotkeyModal')
                },
                '!': function() {
                    if (event.shiftKey) {
                        document.getElementById('timeTrackerDescriptionInput').focus()
                    }
                },
                '@': function() {
                    if (event.shiftKey) {
                        document.getElementById('pomodoroTime').focus()
                    }
                },
                '#': function() {
                    if (event.shiftKey) {
                        document.getElementById('trackerCategoryCategoryInput').focus()
                    }
                },
                '$': function() {
                    if (event.shiftKey) {
                        document.getElementById('trackerTagTagInput').focus()
                    }
                },
                'Escape': function () {
                    const hotkeyModal = document.getElementById('hotkeyModal');
                    if (hotkeyModal.style.display === 'block') {
                        toggleModal('hotkeyModal');
                    }
                    const timeRecordsModal = document.getElementById('timeRecordsModal');
                    if (timeRecordsModal.style.display === 'block') {
                        toggleModal('timeRecordsModal');
                    }
                    const trackerCategoryModal = document.getElementById('trackerCategoryModal');
                    if (trackerCategoryModal.style.display === 'block') {
                        toggleModal('trackerCategoryModal');
                    }
                    const trackerTagModal = document.getElementById('trackerTagModal');
                    if (trackerTagModal.style.display === 'block') {
                        toggleModal('trackerTagModal');
                    }
                }
            }
            if (hotkeyActions[event.key]) {
                event.preventDefault();
                hotkeyActions[event.key]();
            }
        });
    </script>
    <script>
        /* TIMER FUNCTIONS */
        function getSelectedValues(selectElementId) {
            const selectElement = document.getElementById(selectElementId);
            const selectedValues = Array.from(selectElement.selectedOptions)
                                        .map(option => option.value);
            return selectedValues;
        }
        function getTimeRecord({
            description,
            tags,
            startTime,
            stopTime
        }, noCurrentTimeRecord = false) {
            if (currentTimeRecord && !noCurrentTimeRecord) {
                if (stopTime) {
                    currentTimeRecord.stopTime = stopTime.toISOString()
                }
                return currentTimeRecord;
            }

            let taskDescription = document.getElementById('timeTrackerDescriptionInput').value;
            let category = document.getElementById('timeTrackerCategorySelect').value;
            let tagsSelect = getSelectedValues('timeTrackerTagsSelect');

            let record = {
                date: new Date(new Date().getUTCFullYear(), new Date().getUTCMonth(), new Date().getUTCDate()).toISOString(),
                description: description || taskDescription || 'undefined',
                category: category,
                tags: tags ? [...tags, ...tagsSelect] : tagsSelect,
                startTime: startTime ? startTime.toISOString() : undefined,
                stopTime: stopTime ? stopTime.toISOString() : undefined,
            };

            return record;
        }

        function resetCurrentTimeValues() {
            document.getElementById('timeTrackerDescriptionInput').value = '';  // Reset the task description input
            document.getElementById('timerDisplay').textContent = '00:00:00';  // Reset the timer display
            document.getElementById('timerDisplay').style.display = 'block';
            document.getElementById('pomodoroTimerDisplay').innerHTML = '';
            currentStartTime = null;  // Reset any relevant variables
            setDefaultDateForStartTimeAndStopTimeInput();
            intervalId = null;
            currentTimeRecord = null;
            if (timeoutId) {
                clearTimeout(timeoutId)
            }
        }

        function resetTimeTrackerItems() {
            document.getElementById('startButton').style.display = 'inline';
            document.getElementById('startPomodoroTimerButton').style.display = 'inline';
            document.getElementById('startBreakTimerButton').style.display = 'inline';
            document.getElementById('stopButton').style.display = 'none';
            document.getElementById('updateTimeButton').style.display = 'none';
            document.getElementById('addTimeButton').style.display = 'inline';
            document.getElementById('timeTrackerStopTimeInput').style.display = 'inline';
            document.getElementById('setToLastStopTimeTodayButton').style.display = "inline"
        }

        function startTimer(defaultRecord, callback, autoSave = true) {
            if (!intervalId) {
                let record, startTime;

                if (!currentStartTime) {
                    currentStartTime = new Date();
                    startTime = currentStartTime;
                }
                if (callback) {
                    callback();
                } else {
                    intervalId = setInterval(updateTimeTrackerDisplayIncrement, 1000);
                }
                document.getElementById('startButton').style.display = 'none';
                document.getElementById('startPomodoroTimerButton').style.display = 'none';
                document.getElementById('startBreakTimerButton').style.display = 'none';
                document.getElementById('stopButton').style.display = 'inline';
                document.getElementById('updateTimeButton').style.display = 'inline';
                document.getElementById('addTimeButton').style.display = 'none';
                document.getElementById('timeTrackerStopTimeInput').style.display = 'none';

                document.getElementById('timeTrackerStartTimeInput').value = getDateTimeLocalValueFromDate(startTime);

                if (defaultRecord) {
                    record = getTimeRecord({ ...defaultRecord, startTime })
                } else {
                    record = getTimeRecord({ startTime })
                }

                showToast('Timer stated')

                if (autoSave) {
                    return saveTimeRecord(record, true)
                }

            }
        }

        const defaultPomodoroRecord = { tags: ['pomodoro'] }
        function startPomodoroTimer() {
            document.getElementById('timerDisplay').style.display = 'none';
            const timerMin = pomodoroConfig.pomodoroTime;
            const timerMs = timerMin * 60 * 1000
            const curretStartTimeAndPomodoroTime = currentStartTime.getTime() + timerMs // Set start time to 25 minutes from now
            updateTimeTrackerDisplayDecrement(curretStartTimeAndPomodoroTime) // calls the function first to show display
            intervalId = setInterval(function () {
                updateTimeTrackerDisplayDecrement(curretStartTimeAndPomodoroTime)
            }, 1000);
            timeoutId = setTimeout(function () {
                stopTimer();
                alert('Pomodoro finished!');
                startBreakTimer();
            }, timerMs)
            showToast('Pomodoro started')
        }

        const defaultPomodoroBreakRecord = { description: 'Break', tags: ['pomodoro-break'] }
        function startBreakTimer() {
            document.getElementById('pomodoroTimerDisplay').style.display = 'block';
            document.getElementById('timerDisplay').style.display = 'none';
            const timerMin = pomodoroConfig.breakTime;
            const timerMs = timerMin * 60 * 1000
            const curretStartTimeAndPomodoroBreakTime = currentStartTime.getTime() + timerMs // Set start time to 25 minutes from now
            updateTimeTrackerDisplayDecrement(curretStartTimeAndPomodoroBreakTime) // calls the function first to show display
            intervalId = setInterval(function () {
                updateTimeTrackerDisplayDecrement(curretStartTimeAndPomodoroBreakTime)
            }, 1000);
            timeoutId = setTimeout(function () {
                alert('Break finished!');
                stopTimer();
            }, timerMs)
            showToast('Break started')
        }

        async function stopTimer(defaultStopTime) {
            if (timeoutId) {
                clearTimeout(timeoutId)
            }
            if (intervalId) {
                clearInterval(intervalId);
                intervalId = null;
            }

            let stopTime = new Date();
            const record = getTimeRecord({ stopTime: defaultStopTime ? defaultStopTime : stopTime })
            await saveTimeRecord(record, true);

            await fetchTimeTrackerRecords();
            resetCurrentTimeValues();
            resetTimeTrackerItems();
            displayTimeTrackerRecords();

            showToast('Timer stopped')
        }

        async function addTimeRecord() {
            const startTime = new Date(document.getElementById('timeTrackerStartTimeInput').value)
            const stopTime = new Date(document.getElementById('timeTrackerStopTimeInput').value)
            const record = getTimeRecord({ startTime, stopTime })
            await saveTimeRecord(record)

            await fetchTimeTrackerRecords();
            resetCurrentTimeValues();
            resetTimeTrackerItems();
            displayTimeTrackerRecords();
        }

        async function updateTimeRecord() {
            const newStartTime = new Date(document.getElementById('timeTrackerStartTimeInput').value)
            const newRecord = getTimeRecord({ startTime: newStartTime }, true);
            newRecord.key = currentTimeRecord.key
            if (JSON.stringify(newRecord) === JSON.stringify(currentTimeRecord)) {
                return
            }

            saveTimeRecord(newRecord, true)
            showToast('Timer information updated')
        }

        function setToLastStopTimeToday() {
            const latestRecord = timeTrackingRecords[0]
            if (latestRecord && latestRecord.stopTime) {
                document.getElementById('timeTrackerStartTimeInput').value = getDateTimeLocalValueFromDate(new Date(latestRecord.stopTime))
            }
        }

        function updateTimeTrackerDisplayIncrement(date = new Date()) {
            document.getElementById('pomodoroTimerDisplay').style.display = 'none';
            const elapsed = new Date(date - currentStartTime);
            const hours = elapsed.getUTCHours().toString().padStart(2, '0');
            const minutes = elapsed.getMinutes().toString().padStart(2, '0');
            const seconds = elapsed.getSeconds().toString().padStart(2, '0');
            document.getElementById('timerDisplay').textContent = `${hours}:${minutes}:${seconds}`;
        }

        // startTime = current time + extra time needed to start decrementing
        function updateTimeTrackerDisplayDecrement(startTime) {
            document.getElementById('timerDisplay').style.display = 'none';
            const now = new Date();
            const remaining = new Date(startTime - now);
            const hours = remaining.getUTCHours().toString().padStart(2, '0');
            const minutes = remaining.getMinutes().toString().padStart(2, '0');
            const seconds = remaining.getSeconds().toString().padStart(2, '0');
            document.getElementById('pomodoroTimerDisplay').style.display = 'block';
            document.getElementById('pomodoroTimerDisplay').textContent = `${hours}:${minutes}:${seconds}`;
        }

        async function saveTimeRecord({ key, ...record }, doReturnRecord = false) {
            let request;
            const transaction = db.transaction([timeRecordsDB], "readwrite");
            const store = transaction.objectStore(timeRecordsDB);

            if (key) {
                request = await store.put(record, key);
            } else {
                request = await store.add(record);
            }

            request.onsuccess = function(e) {
                if (key) {
                    console.log("Time record updated:", e.target.result);
                } else {
                    console.log("Time record saved with key:", e.target.result);
                }
                if (doReturnRecord) {
                    record.key = e.target.result;
                    currentTimeRecord = record;
                } else {
                    currentTimeRecord = null;
                }
            };

            transaction.oncomplete = function() {
                if (key) {
                    console.log("Time record updated!");
                } else {
                    console.log("Time record saved!");
                }
            };

            transaction.onerror = function(e) {
                if (key) {
                    console.error("Error updating time record: ", e);
                } else {
                    console.error("Error saving time record: ", e);
                }
            };
        }
    </script>
    <script>
        function resetCurrentTrackerCategoryValue() {
            document.getElementById('trackerCategoryCategoryInput').value = '';  // Reset the task description input
        }
        function resetCurrentTrackerTagValue() {
            document.getElementById('trackerTagTagInput').value = '';  // Reset the task description input
        }
        async function createTrackerCategory() {
            const category = document.getElementById('trackerCategoryCategoryInput').value;

            let request;
            const transaction = db.transaction([categoryRecordsDB], "readwrite");
            const store = transaction.objectStore(categoryRecordsDB);

            request = await store.add({ category });

            request.onsuccess = function(e) {
                console.log("Tracker category created with key:", e.target.result);
                showToast('Category created')
                resetCurrentTrackerCategoryValue();
                displayTrackerCategory();
            };

            transaction.oncomplete = function() {
                console.log("Tracker category created!");
            };

            transaction.onerror = function(e) {
                console.error("Error creating tracker category: ", e);
            };
        }
        async function createTrackerTag() {
            const tag = document.getElementById('trackerTagTagInput').value;

            let request;
            const transaction = db.transaction([tagsRecordsDB], "readwrite");
            const store = transaction.objectStore(tagsRecordsDB);

            request = await store.add({ tag });

            request.onsuccess = function(e) {
                console.log("Tracker tag created with key:", e.target.result);
                showToast('Tag created')
                resetCurrentTrackerTagValue();
                displayTrackerTag();
            };

            transaction.oncomplete = function() {
                console.log("Tracker tag created!");
            };

            transaction.onerror = function(e) {
                console.error("Error creating tracker tag: ", e);
            };
        }
    </script>
    <script>
        /**
         * Capitalizes the first letter of a given word.
         * @param {string} word - The word to capitalize.
         * @return {string} The word with the first letter capitalized.
         */
        function capitalizeFirstLetter(word) {
            if (!word) return word; // Return the original word if it's empty or not provided
            return word.charAt(0).toUpperCase() + word.slice(1);
        }
    </script>
    <script>
        if ('serviceWorker' in navigator) {
        window.addEventListener('load', function() {
            navigator.serviceWorker.register('/service-worker.js').then(function(registration) {
            // Registration was successful
            console.log('ServiceWorker registration successful with scope: ', registration.scope);
            }, function(err) {
            // registration failed :(
            console.log('ServiceWorker registration failed: ', err);
            });
        });
        }
    </script>
</body>
</html>
