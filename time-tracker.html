<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Time Tracker</title>
    <style>
    </style>
</head>
<body>
    <div id="timeTracker">
        <h4>Track time</h4>
        <input type="text" id="timeTrackerDescriptionInput" placeholder="Enter task description" />
        <select id="timeTrackerCategorySelect">
            <option value="" selected>Select category</option>
        </select>
        <select id="timeTrackerTagsSelect" multiple>
        </select>
        <div>
            <input type="datetime-local" id="timeTrackerStartTimeInput" />
            <button id="setToLastStopTimeTodayButton" onclick="setToLastStopTimeToday()">Set to last stop time today</button>
        </div>
        <input type="datetime-local" id="timeTrackerStopTimeInput" />
        <br />
        <button id="startButton" onclick="startTimer()">Start</button>
        <button id="startPomodoroTimerButton" onclick="startTimer(defaultPomodoroRecord, startPomodoroTimer)">Start Pomodoro</button>
        <button id="startBreakTimerButton" onclick="startTimer(defaultPomodoroBreakRecord, startBreakTimer)">Start Break</button>
        <div id="startTimeDisplay"></div>
        <button id="stopButton" onclick="stopTimer()">Stop</button>
        <button id="addTimeButton" onclick="addTimeRecord()">Save</button>
        <div id="timerDisplay">00:00:00</div>
        <div id="pomodoroTimerDisplay"></div>
    </div>
    <div>
        <h4>Pomodoro settings</h4>
        <label for="pomodoroTime">Pomodoro time: </label>
        <input type="number" id="pomodoroTime" value="25" min="1"> min
        <button id="savePomodoroButton" onclick="setPomodoroConfigLocalStorage('pomodoro')">Save pomodoro time config</button>
        <br>
        <label for="breakTime">Break time: </label>
        <input type="number" id="breakTime" value="5" min="1"> min
        <button id="savePomodoroButton" onclick="setPomodoroConfigLocalStorage('break')">Save break time config</button>
    </div>
    <h4>Time tracking records</h4>
    <div id="timeTrackerDisplayArea"></div>
    <h4>Categories for time tracking</h4>
    <div id="trackerCategory">
        <input type="text" id="trackerCategoryCategoryInput" placeholder="Enter category" />
        <button onclick="createTrackerCategory()">Save</button>
    </div>
    <div id="trackerCategoryDisplayArea"></div>
    <h4>Tags for time tracking</h4>
    <div id="trackerTag">
        <input type="text" id="trackerTagTagInput" placeholder="Enter tag" />
        <button  onclick="createTrackerTag()">Save</button>
    </div>
    <div id="trackerTagDisplayArea"></div>
    <script>
        let db;
        // DB is NoSQL, but I'd like it to function like a SQL database, with "JOINS"
        const timeRecordsDB = 'timeRecords'
        const categoryRecordsDB = 'categoryRecords'
        const tagsRecordsDB = 'tagsRecords'

        let defaultStartTime, latestRecord;

        const timeTrackingRecords = []
        let pomodoroConfig = {}

        function openDatabase(callbacks) {
            const request = indexedDB.open("TimeTrackerDB", 1);

            request.onupgradeneeded = function(e) {
                db = e.target.result;

                // create object stores
                if (!db.objectStoreNames.contains(timeRecordsDB)) {
                    db.createObjectStore(timeRecordsDB, { autoIncrement: true });
                }
                if (!db.objectStoreNames.contains(categoryRecordsDB)) {
                    const categoryRecordStore = db.createObjectStore(categoryRecordsDB, { autoIncrement: true });
                }
                if (!db.objectStoreNames.contains(tagsRecordsDB)) {
                    const tagRecordStore = db.createObjectStore(tagsRecordsDB, { autoIncrement: true });
                }

                // create indexes
                const upgradeTransaction = event.target.transaction
                if (db.objectStoreNames.contains(categoryRecordsDB)) {
                    const categoryRecordStore = upgradeTransaction.objectStore(categoryRecordsDB)
                    if (!categoryRecordStore.indexNames.contains('category')) {
                        categoryRecordStore.createIndex('category', 'category', { unique: true })
                    }
                }
                if (db.objectStoreNames.contains(tagsRecordsDB)) {
                    const tagRecordsObjectStore = upgradeTransaction.objectStore(tagsRecordsDB)
                    if (!tagRecordsObjectStore.indexNames.contains('tag')) {
                        tagRecordsObjectStore.createIndex('tag', 'tag', { unique: true })
                    // } else {
                        // example of how to reset an index
                        // need to delete it first in 1 upgrade, then in the next upgrade create it back
                        // tagRecordsObjectStore.deleteIndex('tag')
                        // tagRecordsObjectStore.createIndex('tag', 'tag', { unique: true })
                    }
                }
            };

            request.onsuccess = async function(e) {
                db = e.target.result;
                for (let i = 0; i < callbacks.length; i += 1) {
                    await callbacks[i]()
                }
            };

            request.onerror = function(e) {
                console.error("Error opening database: ", e);
            };
        }

        function formatTime(date) {
            let hours = date.getHours();
            const minutes = date.getMinutes().toString().padStart(2, '0');
            const ampm = hours >= 12 ? 'PM' : 'AM';
            hours = hours % 12;
            hours = hours ? hours : 12; // the hour '0' should be '12'
            return hours.toString().padStart(2, '0') + ':' + minutes + ' ' + ampm;
        }

        function formatElapsedTime(elapsedTime) {
            const hours = Math.floor(elapsedTime / (1000 * 60 * 60));
            const minutes = Math.floor((elapsedTime % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((elapsedTime % (1000 * 60)) / 1000);

            return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function displayTimeTrackerRecords() {
            const timeTrackerDisplayArea = document.getElementById('timeTrackerDisplayArea');
            timeTrackerDisplayArea.innerHTML = ''; // Clear previous entries

            // Create a table and header row
            const table = document.createElement('table');
            table.innerHTML = `
                <tr>
                    <th>Description</th>
                    <th>Category</th>
                    <th>Tags</th>
                    <th>Time Range</th>
                    <th>Total Time</th>
                    <th>Actions</th>
                </tr>`;
            timeTrackerDisplayArea.appendChild(table);

            function sortTimeRecordsByLatestToOldest() {
                const recordWNoStopTime = timeTrackingRecords.filter(function(record) {
                    return !record.stopTime
                })[0]
    
                let records = [];
                if (recordWNoStopTime) {
                    records.push(recordWNoStopTime)
                }

                timeTrackingRecords.sort((a,b) => {
                    if (a.stopTime < b.stopTime) { return 1 }
                    else if (a.stopTime > b.stopTime) { return -1 }
                    else return 0
                })

                let recordsWStopTime = timeTrackingRecords.filter(function(record) {
                    return record.stopTime
                })
                
                return [...records, ...recordsWStopTime ] 
            }

            records = sortTimeRecordsByLatestToOldest()

            records.forEach(function(record) {
                const row = table.insertRow();

                const startTime = new Date(record.startTime);
                const stopTime = new Date(record.stopTime);
                const elapsedTime = new Date(stopTime - startTime);

                const timeRange = `${formatTime(startTime)} - ${formatTime(stopTime)}`;
                const totalElapsedTime = formatElapsedTime(elapsedTime);

                createEditableCell(timeRecordsDB, row, record.description, 'editable', record.key, record, 'description');
                createEditableCell(timeRecordsDB, row, record.category, 'editable', record.key, record, 'category');
                const tags = record.tags && record.tags.length > 0 ? record.tags.join(', ') : '';
                createEditableCell(timeRecordsDB, row, tags, 'editable', record.key, record, 'tags');
                createCombinedEditableCell(timeRecordsDB, row, 
                    [{ textContent: formatTime(startTime), field: 'startTime'}, 
                        { textContent: formatTime(stopTime), field: 'stopTime'}], 
                    'editable', record.key, record, ' - ')
                createEditableCell(timeRecordsDB, row, totalElapsedTime);

                // Cell for Edit and Delete buttons
                const actionCell = row.insertCell();
                actionCell.innerHTML = `<button onclick="deleteRecord('${timeRecordsDB}', ${record.key})">Delete</button>`;
            })
        }
        function fetchTimeTrackerRecords() {
            const transaction = db.transaction([timeRecordsDB], "readonly");
            const store = transaction.objectStore(timeRecordsDB);
            const request = store.openCursor();

            request.onsuccess = function(event) {
                const cursor = event.target.result;
                if (cursor) {
                    const record = cursor.value;
                    if (!timeTrackingRecords.some(function(record) {
                        return record.key === cursor.key
                    })) {
                        timeTrackingRecords.push({ ...record, key: cursor.key })
                    }
                    cursor.continue();
                } else {
                    displayTimeTrackerRecords();
                }
            };

            request.onerror = function(event) {
                console.error("Error in retrieving records: ", event);
            };
        }

        function displayTrackerCategory() {
            const transaction = db.transaction([categoryRecordsDB], "readonly");
            const store = transaction.objectStore(categoryRecordsDB);
            const request = store.openCursor();

            const trackerCategoryDisplayArea = document.getElementById('trackerCategoryDisplayArea');
            trackerCategoryDisplayArea.innerHTML = ''; // Clear previous entries

            // Create a table and header row
            const table = document.createElement('table');
            table.innerHTML = `
                <tr>
                    <th>Category</th>
                    <th>Actions</th>
                </tr>`;
            trackerCategoryDisplayArea.appendChild(table);
            resetSelectToDefault('timeTrackerCategorySelect');

            request.onsuccess = function(event) {
                const cursor = event.target.result;
                if (cursor) {
                    const record = cursor.value;
                    const row = table.insertRow();

                    createEditableCell(categoryRecordsDB, row, record.category, 'editable', cursor.key, record, 'category');

                    // Cell for Edit and Delete buttons
                    const actionCell = row.insertCell();
                    // adding quotes because cursor.key is a string and value shows without quotes
                    actionCell.innerHTML = `<button onclick="deleteRecord('${categoryRecordsDB}', ${cursor.key})">Delete</button>`;

                    // also adds the category values to select
                    addOptionToSelect('timeTrackerCategorySelect', cursor.value.category)

                    cursor.continue();
                }
            };

            request.onerror = function(event) {
                console.error("Error in retrieving records: ", event);
            };
        }

        function displayTrackerTag() {
            const transaction = db.transaction([tagsRecordsDB], "readonly");
            const store = transaction.objectStore(tagsRecordsDB);
            const request = store.openCursor();

            const trackerTagDisplayArea = document.getElementById('trackerTagDisplayArea');
            trackerTagDisplayArea.innerHTML = ''; // Clear previous entries

            // Create a table and header row
            const table = document.createElement('table');
            table.innerHTML = `
                <tr>
                    <th>Tag</th>
                    <th>Actions</th>
                </tr>`;
            trackerTagDisplayArea.appendChild(table);
            resetSelectToDefault('timeTrackerTagsSelect', true);

            request.onsuccess = function(event) {
                const cursor = event.target.result;
                if (cursor) {
                    const record = cursor.value;
                    const row = table.insertRow();

                    createEditableCell(tagsRecordsDB, row, record.tag, 'editable', cursor.key, record, 'tag');

                    // Cell for Edit and Delete buttons
                    const actionCell = row.insertCell();
                    // adding quotes because cursor.key is a string and value shows without quotes
                    actionCell.innerHTML = `<button onclick="deleteRecord('${tagsRecordsDB}', ${cursor.key})">Delete</button>`;
                    
                    // also adds the tag values to select
                    addOptionToSelect('timeTrackerTagsSelect', cursor.value.tag)


                    cursor.continue();
                }
            };

            request.onerror = function(event) {
                console.error("Error in retrieving records: ", event);
            };
        }

        function refreshDisplayAccordingToDb(db) {
            if (db === timeRecordsDB) {
                displayTimeTrackerRecords();
            } else if (db === categoryRecordsDB) {
                displayTrackerCategory();
            } else if (db === tagsRecordsDB) {
                displayTrackerTag();
            }
        }

        function getDateTimeLocalValueFromDate(date) {
            if (date) {
                return date.getFullYear() + '-' +
                            (date.getMonth() + 1).toString().padStart(2, '0') + '-' +
                            date.getDate().toString().padStart(2, '0') + 'T' +
                            date.getHours().toString().padStart(2, '0') + ':' +
                            date.getMinutes().toString().padStart(2, '0');
            } else {
                const now = new Date()
                return now.getFullYear() + '-' +
                            (now.getMonth() + 1).toString().padStart(2, '0') + '-' +
                            now.getDate().toString().padStart(2, '0') + 'T' +
                            '00:00'
            }
        }

        function setDefaultDateForStartTimeAndStopTimeInput() {
            defaultStartTime = getDateTimeLocalValueFromDate();
            document.getElementById('timeTrackerStartTimeInput').value = defaultStartTime;
            document.getElementById('timeTrackerStopTimeInput').value = defaultStartTime;
        }

        async function editRecordField(recordDb, key, record, field, value) {
            const transaction = db.transaction([recordDb], "readwrite");
            const store = transaction.objectStore(recordDb);

            // TO BE UPDATED
            const updatedRecord = {...record}
            updatedRecord[field] = value            
            const request = await store.put(updatedRecord, key);

            request.onsuccess = function(e) {
                const record = e.target.result;
                console.log("Record updated successfully", record);
                refreshDisplayAccordingToDb(recordDb); // Refresh the displayed records
            };

            request.onerror = function(e) {
                console.error("Error updating record: ", e.target.error);
            };
        }

        function deleteRecord(recordDb, key) {
            const transaction = db.transaction([recordDb], "readwrite");
            const store = transaction.objectStore(recordDb);
            store.delete(key);

            transaction.oncomplete = function(e) {
                console.log("Record deleted successfully");
                // Refresh the displayed records
                refreshDisplayAccordingToDb(recordDb);
            };

            transaction.onerror = function(e) {
                console.error("Error deleting record: ", e.target.error);
            };
        }

        function addOptionToSelect(elementId, data) {
            const selectElement = document.getElementById(elementId);
            const option = document.createElement('option');
            option.value = data;
            option.textContent = data;
            selectElement.appendChild(option);
        }

        function resetSelectToDefault(elementId, removeFirst = false) {
            const selectElement = document.getElementById(elementId);
            if (removeFirst) {
                selectElement.innerHTML = ''
            } else {
                // Remove all options except the first one
                while (selectElement.options.length > 1) {
                    selectElement.remove(1);
                }
                // Optionally reset the first option to be selected
                selectElement.selectedIndex = 0;
            }
        }

        function fetchPomodoroConfigLocalStorage() {
            const fetchedPomodoroConfig = localStorage.getItem('pomodoroConfig')
            if (fetchedPomodoroConfig) {
                pomodoroConfig = fetchedPomodoroConfig ? JSON.parse(fetchedPomodoroConfig) : {};
                document.getElementById('pomodoroTime').value = pomodoroConfig.pomodoroTime
                document.getElementById('breakTime').value = pomodoroConfig.breakTime
            } else {
                localStorage.setItem('pomodoroConfig', JSON.stringify({
                    pomodoroTime: 25,
                    breakTime: 5
                }))
            }
        }

        function setPomodoroConfigLocalStorage(type) {
            const config = { ...pomodoroConfig }
            console.log(config);
            if (type === 'pomodoro') {
                const pomodoroValue = document.getElementById('pomodoroTime').value
                config.pomodoroTime = pomodoroValue
            } else {
                const breakValue = document.getElementById('breakTime').value
                config.breakTime = breakValue
            }
            pomodoroConfig = config
            localStorage.setItem('pomodoroConfig', JSON.stringify(config))
        }

        document.addEventListener('DOMContentLoaded', async function() {
            setDefaultDateForStartTimeAndStopTimeInput()
            openDatabase([displayTrackerCategory, displayTrackerTag, fetchTimeTrackerRecords, fetchPomodoroConfigLocalStorage]);
        });
    </script>
    <script>
        /* EDIT TABLE CELL FUNCTIONS */
        function createCombinedEditableCell(recordDb, row, contentArr = [{ textContent: '', field: ''}], className, key, record, joinContent) {
            let cell = row.insertCell();
            cell.className = className;

            const combinedHTML = contentArr.map(content => {
                const span = document.createElement('span');
                span.textContent = content.textContent;
                
                if (key) {
                    span.addEventListener('click', function() {
                        makeCellEditable(recordDb, this, key, record, content.field);
                    });
                }

                return span;
            })

            for (let i = 0; i < combinedHTML.length; i += 1) {
                cell.appendChild(combinedHTML[i])
                if (i !== combinedHTML.length - 1) {
                    cell.appendChild(document.createTextNode(joinContent))
                }
            }
        }

        function createEditableCell(recordDb, row, textContent, className, key, record, field) {
            let cell = row.insertCell();
            if (className) {
                cell.className = className;
            }
            cell.textContent = textContent;

            if (key) {
                cell.addEventListener('click', function() {
                    // Your logic to make the cell editable
                    makeCellEditable(recordDb, this, key, record, field);
                });
            }
        }

        /* WORK ON THIS NEXT - ADD IN A TYPE TO CHANGE THE INPUT TYPE WHEN EDITING */
        function makeCellEditable(recordDb, td, key, record, field) {
            const originalText = td.textContent;
            td.innerHTML = `<input type="text" value="${originalText}" />`;
            const input = td.querySelector('input');
            input.focus();

            input.addEventListener('blur', function() {
                td.innerHTML = '';
                td.textContent = originalText; // Or handle updating the record in IndexedDB
                // editRecordField(recordDb, key, record, field, td.textContent)
            });

            input.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    td.textContent = this.value; // Or handle updating the record in IndexedDB
                    editRecordField(recordDb, key, record, field, td.textContent)
                }
            });
        }

    </script>
    <script>
        /* TIMER FUNCTIONS */
        let currentStartTime, intervalId, timeoutId, currentTimeRecord;

        function getTimeRecord({
            description,
            tags,
            startTime,
            stopTime
        }) {
            if (currentTimeRecord) {
                if (stopTime) {
                    currentTimeRecord.stopTime = stopTime.toISOString()
                }
                return currentTimeRecord;
            } 

            let taskDescription = document.getElementById('timeTrackerDescriptionInput').value;
            let category = document.getElementById('timeTrackerCategorySelect').value;

            function getSelectedValues(selectElementId) {
                const selectElement = document.getElementById(selectElementId);
                const selectedValues = Array.from(selectElement.selectedOptions)
                                            .map(option => option.value);
                return selectedValues;
            }
            let tagsSelect = getSelectedValues('timeTrackerTagsSelect');

            let record = {
                date: new Date(new Date().getUTCFullYear(), new Date().getUTCMonth(), new Date().getUTCDate()).toISOString(),
                description: description || taskDescription || 'undefined',
                category: category,
                tags: tags ? [...tags, ...tagsSelect] : tagsSelect,
                startTime: startTime ? startTime.toISOString() : undefined,
                stopTime: stopTime ? stopTime.toISOString() : undefined,
            };

            return record;
        }

        function resetCurrentTimeValues() {
            document.getElementById('timeTrackerDescriptionInput').value = '';  // Reset the task description input
            document.getElementById('timerDisplay').textContent = '00:00:00';  // Reset the timer display
            document.getElementById('timerDisplay').style.display = 'block';
            document.getElementById('pomodoroTimerDisplay').innerHTML = '';
            currentStartTime = null;  // Reset any relevant variables
            setDefaultDateForStartTimeAndStopTimeInput();
            intervalId = null;
            currentTimeRecord = null;
            if (timeoutId) {
                clearTimeout(timeoutId)
            }
        }

        function resetTimeTrackerItems() {
            document.getElementById('startButton').style.display = 'inline';
            document.getElementById('startPomodoroTimerButton').style.display = 'inline';
            document.getElementById('startBreakTimerButton').style.display = 'inline';
            document.getElementById('stopButton').style.display = 'none';
            document.getElementById('addTimeButton').style.display = 'inline';
            document.getElementById('timeTrackerStopTimeInput').style.display = 'inline';
        }

        function startTimer(defaultRecord, callback) {
            if (!intervalId) {
                let record;

                if (!currentStartTime) {
                    currentStartTime = new Date();
                    startTime = currentStartTime;
                }
                if (callback) {
                    callback();
                } else {
                    intervalId = setInterval(updateTimeTrackerDisplayIncrement, 1000);
                }
                document.getElementById('startButton').style.display = 'none';
                document.getElementById('startPomodoroTimerButton').style.display = 'none';
                document.getElementById('startBreakTimerButton').style.display = 'none';
                document.getElementById('stopButton').style.display = 'inline';
                document.getElementById('addTimeButton').style.display = 'none';
                document.getElementById('timeTrackerStopTimeInput').style.display = 'none';

                console.log(startTime, getDateTimeLocalValueFromDate(startTime));
                document.getElementById('timeTrackerStartTimeInput').value = getDateTimeLocalValueFromDate(startTime);

                if (defaultRecord) {
                    record = getTimeRecord({ ...defaultRecord, startTime })
                } else {
                    record = getTimeRecord({ startTime })
                }

                return saveTimeRecord(record, true)

            }
        }

        const defaultPomodoroRecord = { tags: ['pomodoro'] }
        function startPomodoroTimer() {
            document.getElementById('timerDisplay').style.display = 'none';
            const timerMin = document.getElementById('pomodoroTime').value;
            const timerMs = timerMin * 60 * 1000
            const curretStartTimeAndPomodoroTime = currentStartTime.getTime() + timerMs // Set start time to 25 minutes from now
            updateTimeTrackerDisplayDecrement(curretStartTimeAndPomodoroTime) // calls the function first to show display
            intervalId = setInterval(function () {
                updateTimeTrackerDisplayDecrement(curretStartTimeAndPomodoroTime)
            }, 1000);
            timeoutId = setTimeout(function () {
                stopTimer();
                alert('Pomodoro finished!');
                startBreakTimer();
            }, timerMs)
        }

        const defaultPomodoroBreakRecord = { description: 'Break', tags: ['pomodoro-break'] }
        function startBreakTimer() {
            document.getElementById('pomodoroTimerDisplay').style.display = 'block';
            document.getElementById('timerDisplay').style.display = 'none';
            const timerMin = document.getElementById('breakTime').value;
            const timerMs = timerMin * 60 * 1000
            const curretStartTimeAndPomodoroBreakTime = currentStartTime.getTime() + timerMs // Set start time to 25 minutes from now
            updateTimeTrackerDisplayDecrement(curretStartTimeAndPomodoroBreakTime) // calls the function first to show display
            intervalId = setInterval(function () {
                updateTimeTrackerDisplayDecrement(curretStartTimeAndPomodoroBreakTime)
            }, 1000);
            timeoutId = setTimeout(function () {
                alert('Break finished!');
                stopTimer();
            }, timerMs)
        }

        async function stopTimer() {
            if (timeoutId) {
                clearTimeout(timeoutId)
            }
            if (intervalId) {
                clearInterval(intervalId);
                intervalId = null;

                let stopTime = new Date();
                const record = getTimeRecord({ stopTime })

                saveTimeRecord(record);

                resetCurrentTimeValues();
                resetTimeTrackerItems();
                await fetchTimeTrackerRecords();
                displayTimeTrackerRecords();
            }
        }

        async function addTimeRecord() {
            const startTime = new Date(document.getElementById('timeTrackerStartTimeInput').value)
            const stopTime = new Date(document.getElementById('timeTrackerStopTimeInput').value)
            const record = getTimeRecord({ startTime, stopTime })
            await saveTimeRecord(record)

            resetCurrentTimeValues();
            resetTimeTrackerItems();
            await fetchTimeTrackerRecords();
            displayTimeTrackerRecords();

        }

        function setToLastStopTimeToday() {
            const latestRecord = timeTrackingRecords[0]
            if (latestRecord && latestRecord.stopTime) {
                document.getElementById('timeTrackerStartTimeInput').value = getDateTimeLocalValueFromDate(new Date(latestRecord.stopTime))
            }
        }

        function updateTimeTrackerDisplayIncrement() {
            document.getElementById('pomodoroTimerDisplay').style.display = 'none';
            const now = new Date();
            const elapsed = new Date(now - currentStartTime);
            const hours = elapsed.getUTCHours().toString().padStart(2, '0');
            const minutes = elapsed.getMinutes().toString().padStart(2, '0');
            const seconds = elapsed.getSeconds().toString().padStart(2, '0');
            document.getElementById('timerDisplay').textContent = `${hours}:${minutes}:${seconds}`;
        }

        // startTime = current time + extra time needed to start decrementing
        function updateTimeTrackerDisplayDecrement(startTime) {
            document.getElementById('timerDisplay').style.display = 'none';
            const now = new Date();
            const remaining = new Date(startTime - now);
            const hours = remaining.getUTCHours().toString().padStart(2, '0');
            const minutes = remaining.getMinutes().toString().padStart(2, '0');
            const seconds = remaining.getSeconds().toString().padStart(2, '0');
            document.getElementById('pomodoroTimerDisplay').textContent = `${hours}:${minutes}:${seconds}`;
        }

        async function saveTimeRecord({ key, ...record }, doReturnRecord = false) {
            let request;
            const transaction = db.transaction([timeRecordsDB], "readwrite");
            const store = transaction.objectStore(timeRecordsDB);

            if (key) {
                request = await store.put(record, key);
            } else {
                request = await store.add(record);
            }

            request.onsuccess = function(e) {
                if (key) {
                    console.log("Time record updated:", e.target.result);
                } else {
                    console.log("Time record saved with key:", e.target.result);
                }
                if (doReturnRecord) {
                    record.key = e.target.result;
                    currentTimeRecord = record;
                } else {
                    currentTimeRecord = null;
                }
            };

            transaction.oncomplete = function() {
                if (key) {
                    console.log("Time record updated!");
                } else {
                    console.log("Time record saved!");
                }
            };

            transaction.onerror = function(e) {
                if (key) {
                    console.error("Error updating time record: ", e);
                } else {
                    console.error("Error saving time record: ", e);
                }
            };
        }
    </script>
    <script>
        function resetCurrentTrackerCategoryValue() {
            document.getElementById('trackerCategoryCategoryInput').value = '';  // Reset the task description input
        }
        function resetCurrentTrackerTagValue() {
            document.getElementById('trackerTagTagInput').value = '';  // Reset the task description input
        }
        async function createTrackerCategory() {
            const category = document.getElementById('trackerCategoryCategoryInput').value;

            let request;
            const transaction = db.transaction([categoryRecordsDB], "readwrite");
            const store = transaction.objectStore(categoryRecordsDB);

            request = await store.add({ category });

            request.onsuccess = function(e) {
                console.log("Tracker category created with key:", e.target.result);
                resetCurrentTrackerCategoryValue();
                displayTrackerCategory();
            };

            transaction.oncomplete = function() {
                console.log("Tracker category created!");
            };

            transaction.onerror = function(e) {
                console.error("Error creating tracker category: ", e);
            };
        }
        async function createTrackerTag() {
            const tag = document.getElementById('trackerTagTagInput').value;

            let request;
            const transaction = db.transaction([tagsRecordsDB], "readwrite");
            const store = transaction.objectStore(tagsRecordsDB);

            request = await store.add({ tag });

            request.onsuccess = function(e) {
                console.log("Tracker tag created with key:", e.target.result);
                resetCurrentTrackerTagValue();
                displayTrackerTag();
            };

            transaction.oncomplete = function() {
                console.log("Tracker tag created!");
            };

            transaction.onerror = function(e) {
                console.error("Error creating tracker tag: ", e);
            };
        }
    </script>
</body>
</html>
