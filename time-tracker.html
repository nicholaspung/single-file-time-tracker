<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Time Tracker</title>
    <style>
    </style>
</head>
<body>
    <div id="timeTracker">
        <input type="text" id="timeTrackerDescriptionInput" placeholder="Enter task description" />
        <select id="timeTrackerCategorySelect">
            <option value="" selected>Select Category</option>
            <option value="Work">Work</option>
            <option value="Study">Study</option>
        </select>
        <select id="timeTrackerTagsSelect" multiple>
            <option value="Urgent">Urgent</option>
            <option value="Important">Important</option>
            <!-- Add more tags as needed -->
        </select>   
        <button id="startButton" onclick="startTimer()">Start</button>
        <button id="stopButton" onclick="stopTimer()">Stop</button>
        <div id="timerDisplay">00:00:00</div>
    </div>
    <div id="timeTrackerDisplayArea"></div>
    <div id="trackerCategory">
        <input type="text" id="trackerCategoryCategoryInput" placeholder="Enter category" />
        <button onclick="createTrackerCategory()">Save</button>
    </div>
    <div id="trackerCategoryDisplayArea"></div>
    <div id="trackerTag">
        <input type="text" id="trackerTagTagInput" placeholder="Enter tag" />
        <button  onclick="createTrackerTag()">Save</button>
    </div>
    <div id="trackerTagDisplayArea"></div>
    <script>
        let db;
        // DB is NoSQL, but I'd like it to function like a SQL database, with "JOINS"
        const timeRecordsDB = 'timeRecords'
        const categoryRecordsDB = 'categoryRecords'
        const tagsRecordsDB = 'tagsRecords'

        function openDatabase(callbacks) {
            const request = indexedDB.open("TimeTrackerDB", 1);

            request.onupgradeneeded = function(e) {
                db = e.target.result;

                if (!db.objectStoreNames.contains(timeRecordsDB)) {
                    db.createObjectStore(timeRecordsDB, { autoIncrement: true });
                }
                if (!db.objectStoreNames.contains(categoryRecordsDB)) {
                    const categoryRecordStore = db.createObjectStore(categoryRecordsDB, { keyPath: 'category', autoIncrement: true });
                    categoryRecordStore.createIndex('category', 'category', { unique: true })
                }
                if (!db.objectStoreNames.contains(tagsRecordsDB)) {
                    const tagRecordStore = db.createObjectStore(tagsRecordsDB, { keyPath: 'category', autoIncrement: true });
                    tagRecordStore.createIndex('tag', 'tag', { unique: true })
                }
            };

            // request.onupgradeneeded = function(event) {
            //     var db = event.target.result;
            //     var upgradeTransaction = event.target.transaction;
            //     var objectStore;
            //     if (!db.objectStoreNames.contains("my-store")) {
            //     objectStore = db.createObjectStore("my-store");
            //     } else {
            //     objectStore = upgradeTransaction.objectStore('my-store');
            //     }

            //     if (!objectStore.indexNames.contains("my-index")) {
            //     objectStore.createIndex("my-index", "status", { unique: false });
            //     }
            // };

            request.onsuccess = function(e) {
                db = e.target.result;
                for (let i = 0; i < callbacks.length; i += 1) {
                    callbacks[i]()
                }
            };

            request.onerror = function(e) {
                console.error("Error opening database: ", e);
            };
        }

        function formatTime(date) {
            let hours = date.getHours();
            const minutes = date.getMinutes().toString().padStart(2, '0');
            const ampm = hours >= 12 ? 'PM' : 'AM';
            hours = hours % 12;
            hours = hours ? hours : 12; // the hour '0' should be '12'
            return hours.toString().padStart(2, '0') + ':' + minutes + ' ' + ampm;
        }

        function formatElapsedTime(elapsedTime) {
            const hours = Math.floor(elapsedTime / (1000 * 60 * 60));
            const minutes = Math.floor((elapsedTime % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((elapsedTime % (1000 * 60)) / 1000);

            return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function displayTimeTrackerRecords() {
            const transaction = db.transaction([timeRecordsDB], "readonly");
            const store = transaction.objectStore(timeRecordsDB);
            const request = store.openCursor();

            const timeTrackerDisplayArea = document.getElementById('timeTrackerDisplayArea');
            timeTrackerDisplayArea.innerHTML = ''; // Clear previous entries

            // Create a table and header row
            const table = document.createElement('table');
            table.innerHTML = `
                <tr>
                    <th>Description</th>
                    <th>Category</th>
                    <th>Tags</th>
                    <th>Time Range</th>
                    <th>Total Time</th>
                    <th>Actions</th>
                </tr>`;
            timeTrackerDisplayArea.appendChild(table);

            request.onsuccess = function(event) {
                const cursor = event.target.result;
                if (cursor) {
                    const record = cursor.value;
                    const row = table.insertRow();

                    const startTime = new Date(record.startTime);
                    const stopTime = new Date(record.stopTime);
                    const elapsedTime = new Date(stopTime - startTime);

                    const timeRange = `${formatTime(startTime)} - ${formatTime(stopTime)}`;
                    const totalElapsedTime = formatElapsedTime(elapsedTime);

                    createEditableCell(row, record.description, 'editable', cursor.key, record, 'description');
                    createEditableCell(row, record.category, 'editable', cursor.key, record, 'category');
                    createEditableCell(row, record.tags && record.tags.length > 0 ? record.tags.join(', ') : '', 'editable', cursor.key, record, 'tags');
                    createCombinedEditableCell(row, 
                        [{ textContent: formatTime(startTime), field: 'startTime'}, 
                            { textContent: formatTime(stopTime), field: 'stopTime'}], 
                        'editable', cursor.key, record, ' - ')
                    createEditableCell(row, totalElapsedTime);

                    // Cell for Edit and Delete buttons
                    const actionCell = row.insertCell();
                    actionCell.innerHTML = `<button onclick="deleteRecord(${cursor.key})">Delete</button>`;

                    cursor.continue();
                }
            };

            request.onerror = function(event) {
                console.error("Error in retrieving records: ", event);
            };
        }

        function displayTrackerCategory() {
            const transaction = db.transaction([categoryRecordsDB], "readonly");
            const store = transaction.objectStore(categoryRecordsDB);
            const request = store.openCursor();

            request.onsuccess = function(event) {
                const cursor = event.target.result
                if (cursor) {
                    console.log(cursor);
                    cursor.continue()
                }
            }
        }

        function displayTrackerTag() {
            const transaction = db.transaction([tagsRecordsDB], "readonly");
            const store = transaction.objectStore(tagsRecordsDB);
            const request = store.openCursor();

            request.onsuccess = function(event) {
                const cursor = event.target.result
                if (cursor) {
                    console.log(cursor);
                    cursor.continue()
                }
            }
        }

        async function editRecordField(key, record, field, value) {
            const transaction = db.transaction([timeRecordsDB], "readwrite");
            const store = transaction.objectStore(timeRecordsDB);

            // TO BE UPDATED
            const updatedRecord = {...record}
            updatedRecord[field] = value

            const request = await store.put(updatedRecord, key);

            request.onsuccess = function(e) {
                const record = e.target.result;
                console.log("Record updated successfully", record);
                displayTimeTrackerRecords(); // Refresh the displayed records
            };

            request.onerror = function(e) {
                console.error("Error updating record: ", e.target.error);
            };
        }

        function deleteRecord(key) {
            const transaction = db.transaction([timeRecordsDB], "readwrite");
            const store = transaction.objectStore(timeRecordsDB);
            store.delete(key);

            transaction.oncomplete = function() {
                console.log("Record deleted successfully");
                // Refresh the displayed records
                displayTimeTrackerRecords();
            };

            transaction.onerror = function(e) {
                console.error("Error deleting record: ", e.target.error);
            };
        }

        openDatabase([displayTrackerCategory, displayTrackerTag, displayTimeTrackerRecords]);
    </script>
    <script>
        /* EDIT TABLE CELL FUNCTIONS */
        function createCombinedEditableCell(row, contentArr = [{ textContent: '', field: ''}], className, key, record, joinContent) {
            let cell = row.insertCell();
            cell.className = className;

            const combinedHTML = contentArr.map(content => {
                const span = document.createElement('span');
                span.textContent = content.textContent;
                
                if (key) {
                    span.addEventListener('click', function() {
                        makeCellEditable(this, key, record, content.field);
                    });
                }

                return span;
            })

            for (let i = 0; i < combinedHTML.length; i += 1) {
                cell.appendChild(combinedHTML[i])
                if (i !== combinedHTML.length - 1) {
                    cell.appendChild(document.createTextNode(joinContent))
                }
            }
        }

        function createEditableCell(row, textContent, className, key, record, field) {
            let cell = row.insertCell();
            if (className) {
                cell.className = className;
            }
            cell.textContent = textContent;

            if (key) {
                cell.addEventListener('click', function() {
                    // Your logic to make the cell editable
                    makeCellEditable(this, key, record, field);
                });
            }
        }

        /* WORK ON THIS NEXT - ADD IN A TYPE TO CHANGE THE INPUT TYPE WHEN EDITING */
        function makeCellEditable(td, key, record, field) {
            const originalText = td.textContent;
            td.innerHTML = `<input type="text" value="${originalText}" />`;
            const input = td.querySelector('input');
            input.focus();

            input.addEventListener('blur', function() {
                td.textContent = this.value; // Or handle updating the record in IndexedDB
                editRecordField(key, record, field, td.textContent)
            });

            input.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    this.blur(); // Triggers the blur event
                }
            });
        }

    </script>
    <script>
        /* TIMER FUNCTIONS */
        let currentStartTime, intervalId, currentTimeRecord;

        function getTimeRecord({
            startTime,
            stopTime
        }) {
            if (currentTimeRecord) {
                if (stopTime) {
                    currentTimeRecord.stopTime = stopTime.toISOString()
                }
                return currentTimeRecord;
            } 

            let taskDescription = document.getElementById('timeTrackerDescriptionInput').value;
            let category = document.getElementById('timeTrackerCategorySelect').value;

            function getSelectedValues(selectElementId) {
                const selectElement = document.getElementById(selectElementId);
                const selectedValues = Array.from(selectElement.selectedOptions)
                                            .map(option => option.value);
                return selectedValues;
            }
            let tags = getSelectedValues('timeTrackerTagsSelect');

            let record = {
                date: new Date(new Date().getUTCFullYear(), new Date().getUTCMonth(), new Date().getUTCDate()).toISOString(),
                description: taskDescription || 'undefined',
                category: category,
                tags: tags,
                startTime: startTime ? startTime.toISOString() : undefined,
                stopTime: stopTime ? stopTime.toISOString() : undefined,
            };

            return record;
        }

        function resetCurrentTimeValues() {
            document.getElementById('timeTrackerDescriptionInput').value = '';  // Reset the task description input
            document.getElementById('timerDisplay').textContent = '00:00:00';  // Reset the timer display
            currentStartTime = null;  // Reset any relevant variables
            intervalId = null;
            currentTimeRecord = null;
        }

        function startTimer() {
            if (!intervalId) {
                if (!currentStartTime) {
                    currentStartTime = new Date();
                }
                intervalId = setInterval(updateTimeTrackerDisplay, 1000);
                document.getElementById('startButton').style.display = 'none';
                document.getElementById('stopButton').style.display = 'inline';

                let startTime = new Date();
                const record = getTimeRecord({ startTime })

                saveTimeRecord(record, true)
            }
        }

        function stopTimer() {
            if (intervalId) {
                clearInterval(intervalId);
                intervalId = null;

                let stopTime = new Date();
                const record = getTimeRecord({ stopTime })

                saveTimeRecord(record);

                resetCurrentTimeValues()
                document.getElementById('startButton').style.display = 'inline';
                document.getElementById('stopButton').style.display = 'none';
                displayTimeTrackerRecords()
            }
        }

        function updateTimeTrackerDisplay() {
            const now = new Date();
            const elapsed = new Date(now - currentStartTime);
            const hours = elapsed.getUTCHours().toString().padStart(2, '0');
            const minutes = elapsed.getMinutes().toString().padStart(2, '0');
            const seconds = elapsed.getSeconds().toString().padStart(2, '0');
            document.getElementById('timerDisplay').textContent = `${hours}:${minutes}:${seconds}`;
        }

        async function saveTimeRecord({ key, ...record }, doReturnRecord = false) {
            let request;
            const transaction = db.transaction([timeRecordsDB], "readwrite");
            const store = transaction.objectStore(timeRecordsDB);

            if (key) {
                request = await store.put(record, key);
            } else {
                request = await store.add(record);
            }

            request.onsuccess = function(e) {
                if (key) {
                    console.log("Time record updated:", e.target.result);
                } else {
                    console.log("Time record saved with key:", e.target.result);
                }
                if (doReturnRecord) {
                    record.key = e.target.result;
                    currentTimeRecord = record;
                } else {
                    currentTimeRecord = null;
                }
            };

            transaction.oncomplete = function() {
                if (key) {
                    console.log("Time record updated!");
                } else {
                    console.log("Time record saved!");
                }
            };

            transaction.onerror = function(e) {
                if (key) {
                    console.error("Error updating time record: ", e);
                } else {
                    console.error("Error saving time record: ", e);
                }
            };
        }
    </script>
    <script>
        async function createTrackerCategory() {
            const category = document.getElementById('trackerCategoryCategoryInput').value;

            let request;
            const transaction = db.transaction([categoryRecordsDB], "readwrite");
            const store = transaction.objectStore(categoryRecordsDB);

            request = await store.add({ category });

            request.onsuccess = function(e) {
                console.log("Tracker category created with key:", e.target.result);
            };

            transaction.oncomplete = function() {
                console.log("Tracker category created!");
            };

            transaction.onerror = function(e) {
                console.error("Error creating tracker category: ", e);
            };
        }
        async function createTrackerTag() {
            const tag = document.getElementById('trackerTagTagInput').value;

            let request;
            const transaction = db.transaction([tagsRecordsDB], "readwrite");
            const store = transaction.objectStore(tagsRecordsDB);

            request = await store.add({ tag });

            request.onsuccess = function(e) {
                console.log("Tracker tag created with key:", e.target.result);
            };

            transaction.oncomplete = function() {
                console.log("Tracker tag created!");
            };

            transaction.onerror = function(e) {
                console.error("Error creating tracker tag: ", e);
            };
        }
    </script>
</body>
</html>
